# designing the growth lattice
For generating the final building, not all voxels are appropriate to use. In this simulation, the growth lattice is being limited by two factors. With generating the building the surroundings are taken into account, and decided is that the building may not cast too much shadow to buildings in the surrounding. Next to that, a limit on the used ground floor space is asked, as 30% of the plot should be reserved for greenery.


### Shadow and Skylight blocking
Based on the ladybug sunpath the shadow envelope is calculated. To do so a ray is cast from the centroids of all the voxel that have received sun, towards the context. If the ray does not intersect the context, then the voxel does not cast a shadow. The shadow envelope is then interpolated to a highres value. 


For Skylight blocking all these steps are repeated, but instead of loading a sunpath, a sphere is created to represent the sky. Instead of shooting rays towards the sunpoints, the rays are being shot to the skypoints. 

<center><img src="https://media.discordapp.net/attachments/785803868356476958/803590073899155456/shadow_and_skylight_blocking.jpg?width=948&height=670">

*method of skylight and sun blocking* </center>

Fundamentally our building should be of least disturbance for the surrounding area, so it would not make sense to keep voxels that cast too much shadow or block too much skylight. Therefore, the voxels that cast too much shadow and block too much skylight from the context are removed.

<center><img src="https://cdn.discordapp.com/attachments/775754717346791494/801507211003822190/shadow.png">

*Sun blocking calculation*



<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/2.0_skyview.png?raw=true">

*skylight blocking calculation*

<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/size_restricted.gif?raw=true" style="width:150%;" >

*Threshold* 

<img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/2.2_newfulllattice.png?raw=true">

*New envelope*
</center>

## greenery
For the plot, 30% should be dedicated to becoming a greenspace. The location of this greenspace could be generated in three different ways: 

1.	By hardcoding where the park should be located, for example based on observations made in the surroundings. 
2.	By checking which ground level voxels would be most suitable for  greenery; checking for sun, noise and daylight, and also closeness to   certain functions.
3.	By checking which ground level voxels are least useful for generating the building, and removing those from the growth model.

The first one is a more classic architectural way of designing, and would therefore not fit in our ambitions to create a generative building. The second option would be very interesting. Only this calculation would be useless if the final form of the building would not be taken into account, so doing this the greenery should be part of the agent based model. Not only this, but the agent based model would need an iteration for the sun- and daylight blockage towards the greenery for every growth step, since the most hinder of sun- and daylight would be generated by buildings that are closest to the greenery, being the generative building itself. Next to that, also the voxel values that are above the selected greenery should be taken into account for each iteration. This because by placing a greenery voxel, all voxels above (or all voxels that do not leave a certain value of day-and sunlight available for the voxel) should be removed from the availability lattice. It would be a waste of good voxels if these voxels are very valuable, whilst the greenery voxel would be almost as satisfied with another voxel. There is need for a balance of value in voxels that are discarded because of the greenspace and voxels that are selected for greenspace. 
Because of the complexity of this system and the lack of worth if not done well, this is not the method that has been executed. For this design, the last method was chosen, finding the average worth of each voxel and removing all voxels that have a low value. This should be done in a two dimensional way, because the greenery will occupy the full height if it takes the ground level voxel. 
 
For each voxel, the multiplication of all values that are associated with that location are being taken. Then this value is being summed for all voxels in the z-direction, creating a two dimensional value for each location. After normalizing this value, it is copied to all z-voxels so if a value is lower than the threshold, all voxels in that z-direction are being removed. 

<center><img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/4.1_averagevoxelval.png?raw=true">

*average voxel value* 
</center>
By then determining the minimum voxel value that is needed to clear 30% of the location, all values that are lower are being removed and all other voxels are being multiplied with the availability lattice that had been generated based on shadow. This results in the final availability lattice, and in the space dedicated for greenery. 

<center><img src="https://github.com/EdaAkaltun/spatial_computing_project_template/blob/master/docs/img/finalscreenshots/4.2_new_avail_lattice.png?raw=true">

*final availability lattice* 
</center>

### Evaluation of the location and the shape of the greenery 
Because of the many entrances that have been generated at the more accessible side of the plot, the distance values of these voxels are relatively impactful for the average value lattice, leaving a low-valued space at the north of the plot. This directly results in a greenspace that is not as open-oriented, but that is more encapsulated behind the building and oriented towards local users. This fits in with our concept of the greenery, that would be a place for retreat and also a place to have a food garden for the neighbourhood and the communal kitchen. 

### Improvements
As has been stated in the decision for this type of greenery selection, a much more complex way of determining the location of the greenery would be possible, but a self-evaluation loop for sun- and daylight would be needed, as well as the implementation of current voxel value evaluation with implementation of the greenery voxel values. This would be very useful, but was not manageable within the given timeframe.         